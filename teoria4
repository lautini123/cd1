ğŸ“Œ Tema 4: Listas, indexaciÃ³n y mutabilidad. IteraciÃ³n y ciclo while
â—Antes de comenzar con la clase, hacete una copia de este documento asÃ­ podÃ©s editarlo y guardar los cambios.

HacÃ© clic acÃ¡ arriba, donde dice "Copiar en Drive".

Luego seguÃ­s trabajando en esa copia y te queda todo guardado en tu Drive.

ğŸ“ˆ De pocos a muchos datos...
Una tienda ha registrado sus ventas mensuales durante todo un aÃ±o, de enero a diciembre.

Los datos de ventas (en miles de unidades) son los siguientes: 320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330.

Al principio, alguien pensÃ³ en guardar cada dato por separado:

ventas_enero = 320
ventas_febrero = 280
ventas_marzo = 310
# ...
ventas_diciembre = 330
ğŸ¤¯ Â¡Pero son demasiadas variables!

Â¿HabrÃ¡ una forma mÃ¡s prÃ¡ctica de guardar esta informaciÃ³n en la compu? ğŸ¤”

MirÃ¡ este cÃ³digo, lÃ©e cada lÃ­nea y pensÃ¡ quÃ© hace. DespuÃ©s ejecutalo para ver los resultados:


[ ]
ventas = [320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330]
print(ventas)

print(ventas[1])
print(ventas[5])
print(ventas[11])

print(ventas[0:3])
print(ventas[3:6])
print(ventas[6:9])
print(ventas[9:12])
[320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330]
280
360
330
[320, 280, 310]
[290, 340, 360]
[410, 390, 370]
[350, 300, 330]
ğŸ“Œ RespondÃ©:

Â¿QuÃ© hace la lÃ­nea ventas = [320, 280, ...]? guarda el valor de todas las ventas durante el aÃ±o
Â¿QuÃ© valores muestran ventas[0], ventas[5] y ventas[11]? Â¿A quÃ© meses corresponden? enero, junio, diciembre
Â¿QuÃ© pasa si cambiÃ¡s ventas[0] por ventas[1]? Â¿Y si probÃ¡s ventas[-1]? me muestra febrero, y diciembre
Â¿QuÃ© valores devuelven ventas[0:3], ventas[3:6], etc.? Â¿QuÃ© parte del aÃ±o representa cada una? los trimestres
ğŸ“‹ Listas
En el ejemplo anterior usamos una lista para guardar las ventas mensuales de una tienda.

Una lista es una estructura de datos que permite almacenar varios valores en un solo lugar.

En lugar de escribir una variable para cada mes del aÃ±o, agrupamos todos los datos en una sola lista:

ventas = [320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330]
En el ejemplo, cada nÃºmero representa las ventas de un mes del aÃ±o, desde enero hasta diciembre, en ese orden.

Los valores que contiene una lista se llaman elementos. En este caso, la lista ventas tiene 12 elementos.

El primer elemento es 320, el segundo 280, el tercero 310, y asÃ­ sucesivamente.

Usar listas es muy Ãºtil cuando la cantidad de datos es grande o puede cambiar. AdemÃ¡s, nos permite acceder fÃ¡cilmente a cualquier valor o conjunto de valores, como veremos a continuaciÃ³n.

ğŸ”¢ IndexaciÃ³n
Cada elemento de la lista ocupa una posiciÃ³n, que se llama Ã­ndice.

En Python, los Ã­ndices comienzan en 0 y aumentan de uno en uno hacia la derecha. Estos son los Ã­ndices positivos.

El Ã­ndice 0 representa el primer elemento, 1 el segundo, y asÃ­ sucesivamente:

print(ventas[0])   # 320 â†’ primer mes (enero)
print(ventas[1])   # 280 â†’ segundo mes (febrero)
print(ventas[2])   # 310 â†’ tercer mes (marzo)
Como los Ã­ndices empiezan en 0, el Ãºltimo Ã­ndice de una lista se obtiene restando 1 al nÃºmero total de elementos. En el ejemplo, como la lista ventas tiene 12 elementos, el Ã­ndice del Ãºltimo elemento es 11.

TambiÃ©n podemos usar Ã­ndices negativos para contar desde el final.

El Ã­ndice -1 representa el Ãºltimo elemento, -2 el penÃºltimo, y asÃ­ sucesivamente:

print(ventas[-1])  # 330 â†’ Ãºltimo mes (diciembre)
print(ventas[-2])  # 300 â†’ penÃºltimo mes (noviembre)
print(ventas[-3])  # 350 â†’ antepenÃºltimo mes (octubre)
En resumen:

Los Ã­ndices positivos cuentan desde el principio de la lista y son Ãºtiles cuando conocemos la posiciÃ³n desde el inicio de la lista.
Los Ã­ndices negativos cuentan desde el final de la lista y permiten acceder fÃ¡cilmente a los Ãºltimos elementos.
ğŸ° Rebanado
TambiÃ©n podemos extraer una parte de la lista. Esto se conoce como rebanado (o slicing, en inglÃ©s).

Para ello, se utiliza la notaciÃ³n i:j, donde i y j son Ã­ndices.

Esta notaciÃ³n devuelve una sublista que va desde el Ã­ndice i hasta el Ã­ndice j, pero sin incluir este Ãºltimo.

Esto significa que abarca desde i hasta j-1 inclusive, siendo el intervalo cerrado a la izquierda y abierto a la derecha.

print(ventas[0:3])  # [320, 280, 310] â†’ primer trimestre (enero a marzo)
print(ventas[3:6])  # [290, 340, 360] â†’ segundo trimestre (abril a junio)
print(ventas[6:9])  # [410, 390, 370] â†’ tercer trimestre (julio a septiembre)
print(ventas[9:12]) # [350, 300, 330] â†’ cuarto trimestre (octubre a diciembre)
La operaciÃ³n de rebanado devuelve una nueva lista con la porciÃ³n deseada de la lista original.

Se puede usar para hacer copias de partes de la lista o incluso de la lista completa.

Podemos omitir el primer o el segundo Ã­ndice para indicar que queremos ir desde el principio o hasta el final:

print(ventas[:3])   # [320, 280, 310] â†’ desde el inicio hasta antes del Ã­ndice 3
print(ventas[9:])   # [350, 300, 330] â†’ desde el Ã­ndice 9 hasta el final
print(ventas[:])    # [320, 280, ..., 330] â†’ desde el inicio hasta el final
Esto hace el cÃ³digo mÃ¡s limpio y fÃ¡cil de leer, especialmente cuando no necesitamos especificar ambos extremos.

â© Paso (tercer Ã­ndice)

Podemos agregar un tercer nÃºmero usando la notaciÃ³n i:j:k, donde k es el paso:

print(ventas[::2])    # [320, 310, 340, 410, 370, 300] â†’ los elementos en posiciones pares
print(ventas[1::2])   # [280, 290, 360, 390, 350, 330] â†’ los elementos en posiciones impares
print(ventas[::-1])   # [330, 300, 350, ..., 320] â†’ lista en orden inverso
El paso permite saltar elementos, seleccionar patrones (como meses alternos) o invertir el orden de una lista.


[ ]
producto=["harina", "leche", "tomate", "azucar", "agua"]
print(producto)
cantidad=[1,2,3,48,9]
print(cantidad)
precios=[1000,2480,1800,2100,900]
ventas=[True, False, True, True, False]
['harina', 'leche', 'tomate', 'azucar', 'agua']
[1, 2, 3, 48, 9]

[ ]
a = [10, 20, 30, 40, 50]

print(a[:2])
print(a[-2:])
print(a[2:1])
print(a[2:2])
print(a[2:3])
print(a[:-1])
print(a[:])
print(a[::2])
print(a[1::2])

[10, 20]
[40, 50]
[]
[]
[30]
[10, 20, 30, 40]
[10, 20, 30, 40, 50]
[10, 30, 50]
[20, 40]
ğŸ§  Preguntas:

Las listas pueden guardar cualquier tipo de dato. Para practicar, creÃ¡ una lista para cada uno de estos casos:

Los nombres de cinco productos distintos de una tienda.
Las cantidades disponibles de esos productos.
Los precios correspondientes de cada producto.
Las ventas (sÃ­ o no) de cada producto en el Ãºltimo mes (usando valores True o False).
Â¿Es posible mezclar distintos tipos de datos dentro de una misma lista? Por ejemplo:

 mezcla = [42, 3.14, "hola", True, [1, 2, 3]]
Â¿QuÃ© tipo de dato tiene cada elemento? entero, float, string, booleano, lista
Â¿QuÃ© pasa si accedÃ©s al Ãºltimo elemento y luego a uno de sus elementos, como mezcla[-1][1]?
Dada la lista a = [10, 20, 30, 40]:

Â¿CuÃ¡l es el rango vÃ¡lido de Ã­ndices positivos?0,3
Â¿Y el rango vÃ¡lido de Ã­ndices negativos?-1,-4
Con la misma lista a = [10, 20, 30, 40, 50], probÃ¡ las siguientes expresiones y analizÃ¡ quÃ© devuelven:

 a[:2]
 a[-2:]
 a[2:1]
 a[2:2]
 a[2:3]
 a[:-1]
 a[:]
 a[::2]
 a[1::2]
Â¿Por quÃ© algunas devuelven una lista vacÃ­a? Â¿Tienen sentido esas expresiones?
Â¿Es lo mismo a[2] que a[2:3]? Â¿QuÃ© devuelve cada una?
Con la misma lista a = [10, 20, 30, 40, 50], escribÃ­ expresiones para obtener estas sublistas:

 [10, 20, 30]
 [30, 40, 50]
 [20, 30, 40]
 [10, 20, 30, 40]
 [10, 20, 30, 40, 50]
 [10, 30, 50]
 [20, 40]
Consejos:

TratÃ¡ de omitir el primer o segundo Ã­ndice cuando puedas, para que el cÃ³digo quede mÃ¡s claro.
ProbÃ¡ usar Ã­ndices negativos cuando sea conveniente.
âœï¸ Respuestas:

...
...
...
...
...
ğŸ§® AnÃ¡lisis de ventas
Una persona quiso trabajar con los datos de ventas de la tienda, como lo hicimos antes... pero cometiÃ³ algunos errores. ğŸ˜¬

MirÃ¡ este fragmento de su cÃ³digo:


[ ]
# Define la lista de ventas mensuales
ventas = [320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330]

# Muestra todas las ventas
print(ventas)

# Muestra las ventas de febrero
print(ventas[1])

# Muestra las ventas del segundo trimestre
print(ventas[3:6])

# Muestra las ventas de diciembre
print(ventas[11])
[320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330]
280
[290, 340, 360]
330
ğŸ˜… Algo no anda bien... Â¿podÃ©s encontrar todos los errores?

ğŸ“Œ RespondÃ©:

Â¿QuÃ© errores ves en la lÃ­nea donde se define la lista ventas?
Â¿Por quÃ© falla ventas[1.0]?
Â¿QuÃ© creÃ©s que quiso hacer con ventas[3;6]?
Â¿QuÃ© pasa con el Ã­ndice 12?
ğŸ Errores al trabajar con listas
Cuando empezamos a programar, es muy normal cometer errores al usar listas. En el ejemplo vimos algunos de los errores mÃ¡s comunes.

Las listas se definen entre corchetes [] y cada valor debe ir separado por comas. Si olvidamos un corchete, una coma o usÃ¡mos un punto y coma ;, la compu no va a entender lo que queremos hacer y nos va a tirar un error de sintaxis (SyntaxError).

Si escribimos mal el nombre de la variable en la que guardamos la lista, como en print(venta), la compu nos mostrarÃ¡ un error de nombre (NameError). Lo correcto en este caso es print(ventas).

Por otro lado, para indexar a un elemento de la lista usamos un Ã­ndice entre corchetes. El Ã­ndice es un nÃºmero entero (int), no podemos usar nÃºmeros con decimales ni otras cosas raras. AdemÃ¡s, la sintaxis para indexar un valor es escribir el nombre de la variable y el Ã­ndice entre corchetes, como ventas[1]. En cualquier otro caso, obtendremos un error de sintaxis.

En cuanto al rebanado, para acceder a una porciÃ³n de la lista escribimos los Ã­ndices de inicio y fin separÃ¡ndolos con dos puntos :. Si usamos otro sÃ­mbolo como el punto y coma, el cÃ³digo no funcionarÃ¡. La forma correcta para nuestro caso serÃ­a escribir ventas[3:6].

Un error muy comÃºn a la hora de indexar un elemento en una lista es intentar acceder a un valor en una posiciÃ³n que no existe. Esto lo vemos en Ãºltimo ejemplo: print(ventas[12]). En este caso la lista ventas tiene 12 elementos, eso quiere decir que los Ã­ndices vÃ¡lidos van del 0 al 11 (o del -1 al -12 si contamos desde el final usando Ã­ndices negativos). Cualquier otro nÃºmero que usemos como Ã­ndice fuera de este rango nos darÃ¡ el famoso IndexError. Para acceder al Ãºltimo elemento, lo correcto serÃ­a escribir ventas[11] o ventas[-1].

ğŸ§  Preguntas:

Si una lista tiene n elementos:

Â¿CuÃ¡l es el rango vÃ¡lido de Ã­ndices positivos?
Â¿Y el rango vÃ¡lido de Ã­ndices negativos?
ObservÃ¡ este cÃ³digo:

 x = [0, 2, 4, 6, 8, 10]
 y = x[1:5]
 print(y[1])
 print(y[-1])
Â¿QuÃ© valores contiene la variable y?
Â¿QuÃ© se muestra en pantalla?
Â¿Por quÃ© este cÃ³digo da error?:

 colores = ["rojo", "verde", "azul", "amarillo", "naranja"]
 print(colores[5])
En el siguiente cÃ³digo, Â¿quÃ© valores puede tomar i para que se muestre correctamente un valor de la lista precios?

 precios = [150, 180, 170, 160, 200]
 n = len(precios)
 i = ...
 print(precios[n-i])
IdentificÃ¡ quÃ© lÃ­neas generan errores y explicÃ¡ por quÃ©.

 productos = ["pan", "carne", "queso", "yerba", "manteca"]
 n = len(productos)

 print(productos["2"])
 print(productos[n])
 print(productos[2:1])
 print(productos[1.0])
 print(productos[1:10])
âœï¸ Respuestas:

...
...
...
...
...
ğŸ”§ Operaciones con listas
Una persona estÃ¡ trabajando con los registros de ventas mensuales de la tienda de aÃ±os anteriores.

Esta vez se dio cuenta de que necesita completar algunos meses que quedaron sin datos, porque se borraron accidentalmente ğŸ˜±.

AdemÃ¡s, quiere actualizar otros datos que estaban mal cargados.

MirÃ¡ este fragmento de su cÃ³digo y pensÃ¡ quÃ© estÃ¡ intentando hacer. DespuÃ©s ejecutalo para ver los resultados:


[ ]
ventas_2022 = [300, 290, 310, 305, 330, 350, 370, 360, 340]  # Enero a septiembre

# Estima los Ãºltimos 3 meses del aÃ±o con el mismo valor
ventas_estimadas = [320] * 3

ventas_2022_completas = ventas_2022 + ventas_estimadas
print("Ventas 2022 completas:", ventas_2022_completas)

# CorrecciÃ³n: el valor de febrero estaba mal
ventas_2022_completas[1] = 295
print("Ventas 2022 corregidas:", ventas_2022_completas)
ğŸ“Œ RespondÃ©:

Â¿QuÃ© pasa cuando hacemos ventas_2022 + ventas_estimadas?
Â¿QuÃ© hace [320] * 3?
Â¿QuÃ© pasa con la lista ventas_2022_completas luego de hacer ventas_2022_completas[1] = 295?
â• Concatenar y repetir listas
Cuando usamos el operador + con dos o mÃ¡s listas, no se realiza una suma de los valores como si fueran nÃºmeros.

En cambio, se produce una concatenaciÃ³n: las listas se unen en una sola lista, mantieniendo el orden de los elementos.

En el ejemplo, concatenamos las ventas reales y las ventas estimadas de 2022:

ventas_2022_completas = ventas_2022 + ventas_estimadas
La variable ventas_2022_completas ahora contendrÃ¡ todos los valores de ventas_2022 seguidos por los valores de ventas_estimadas.

TambiÃ©n podemos usar el operador * para repetir una lista varias veces. El resultado es otra lista que contiene copias de los elementos.

En el ejemplo, usamos repeticiÃ³n para representar tres meses con las mismas ventas:

ventas_estimadas = [320] * 3
Esto crea una nueva lista con tres elementos iguales [320, 320, 320] que se guarda en la variable ventas_estimadas.

ğŸ“Œ Concatenar o repetir una lista genera una nueva lista.

âœï¸ Creando listas usando concatenaciÃ³n

La concatenaciÃ³n tambiÃ©n nos permite crear una nueva lista que incluye elementos al principio, al final o en el medio de otra lista.

En realidad, no estamos cambiando la lista original, sino que estamos combinando listas para generar una nueva, y luego guardamos ese resultado en la misma variable (si queremos).

ProbÃ¡ estos ejemplos:


[ ]
# Agregar al final
a = [1, 2, 3, 4]
a = a + [5]
print(a)

# Agregar al comienzo
a = [1, 2, 3, 4]
a = [0] + a
print(a)

# Agregar en el medio
a = [1, 2, 3, 4]
a = a[0:2] + [5] + a[2:4]
print(a)
TambiÃ©n podemos armar una lista desde cero empezando con una lista vacÃ­a e ir agregando elementos paso a paso:


[ ]
a = []
a = a + [1]
a = a + [2]

print(a)
Este mÃ©todo es muy Ãºtil cuando queremos construir una lista en base a ciertas condiciones o resultados intermedios.

ğŸ“Œ Cada vez que hacemos algo como a = a + [valor], no estamos modificando la lista original, sino que creamos una nueva lista y reasignamos el resultado a la misma variable.

ğŸ§¬ Mutabilidad
Hasta ahora vimos ejemplos donde usÃ¡bamos operadores como + o * para crear nuevas listas a partir de otras.

Pero hay algo mÃ¡s, las listas tienen una propiedad importante: se pueden modificar directamente sin necesidad de crear una nueva. A esto se le llama mutabilidad.

MirÃ¡ este ejemplo:

ventas_2022_completas = [300, 290, 310, 305, 330, 350, 370, 360, 340, 320, 320, 320]
ventas_2022_completas[1] = 295
En la segunda lÃ­nea, haciendo ventas_2022_completas[1] = 295 reemplazamos el segundo valor de la lista (el 290) por 295.

DespuÃ©s de que la compu ejecute esa lÃ­nea, la lista ventas_2022_completas queda asÃ­:

[300, 295, 310, 305, 330, 350, 370, 360, 340, 320, 320, 320]
Fijate como en lugar del 290 ahora estÃ¡ el 295. No se genera una lista nueva, simplemente modificamos el contenido existente.

ğŸ” Tipos de datos mutables e inmutables

La mutabilidad es una propiedad de algunos tipos de datos secuenciales, como las listas, que permite modificarlos directamente.

En cambio, otros tipos de datos primitivos, como los enteros, las cadenas de texto y los booleanos son inmutables, es decir, no se pueden modificar directamente. Si intentÃ¡s cambiarlos, en realidad estÃ¡s generando un nuevo valor en otra parte de la memoria.

Veamos este ejemplo:


[ ]
x = 1
y = x
y = 2

print(x)
print(y)
Aunque y empieza con el mismo valor que x, cuando cambiamos y, x sigue igual. Â¿Por quÃ©? ğŸ¤”

Porque y = x copia el valor (no la posiciÃ³n en memoria). Las variables quedan desconectadas entre sÃ­.

ğŸ” PodÃ©s visualizar esto en Python Tutor acÃ¡. Fijate cÃ³mo las variables no comparten la misma posiciÃ³n en memoria.

ğŸ“¦ Â¿QuÃ© pasa con los tipos mutables y las asignaciones?

Cuando trabajamos con tipos mutables la cosa cambia: la asignaciÃ³n de variables no copia el contenido, sino que copia la referencia (la direcciÃ³n en memoria). Es decir, ambas variables apuntan al mismo objeto. Por lo tanto, si modificamos la lista desde una variable, la otra tambiÃ©n se ve afectada.

Por ejemplo:


[ ]
a = [1, 2, 3]
b = a
b[0] = 0

print(a)
print(b)
En la asignaciÃ³n b = a, no se pasa la lista como valor, sino la referencia a la posiciÃ³n de memoria donde estÃ¡ la lista.

De esta manera, tanto a como b apuntan a la misma lista. AsÃ­, modificar b tambiÃ©n modifica a.

ğŸ” PodÃ©s ver este ejemplo en Python Tutor acÃ¡. ObservÃ¡ cÃ³mo ambas variables comparten la misma lista en memoria.

ğŸ§¾ En resumen:

âœ… Las listas son mutables: se pueden modificar directamente.
ğŸš« Los nÃºmeros, cadenas y booleanos son inmutables: no se pueden modificar, solo reemplazar.
Â¿QuÃ© pasa cuando hacemos var1 = var2?
Si var2 es inmutable, se copia el valor. ğŸ‘‰ var1 y var2 quedan independientes.
Si var2 es mutable, se copia la referencia. ğŸ‘‰ var1 y var2 apuntan al mismo objeto en memoria.
ğŸ§  Preguntas:

ObservÃ¡ este cÃ³digo:
 a = [0, 1]
 b = [2]
 c = a * 2 + b
 d = c[1:4]
 print(d[-1])
Â¿QuÃ© valores contienen las variables c y d?
Â¿QuÃ© se muestra en pantalla?
Si x es una lista y queremos agregarle el valor 1, Â¿quÃ© pasa si hacemos x = x + 1? Â¿QuÃ© falta para concatenar correctamente?
Dado z = [10, 20, 30, 40], realizÃ¡ las siguientes operaciones y reasignÃ¡ el resultado nuevamente a z cuando corresponda:
InsertÃ¡ el nÃºmero 100 entre el segundo y tercer elemento.
EliminÃ¡ el Ãºltimo elemento de la lista.
ReemplazÃ¡ el segundo elemento por 200.
ObservÃ¡ este cÃ³digo:
 a = [1, 2, 3]
 b = a[:]
 b[0] = 0
 print(a)
 print(b)
Â¿CuÃ¡l es el valor de las variables a y b luego de ejecutar este cÃ³digo?
Â¿QuÃ© diferencia hay entre hacer b = a[:] y hacer b = a? Â¿CuÃ¡ndo se copia una lista y cuÃ¡ndo se pasa solo una referencia?
ObservÃ¡ este cÃ³digo:
 a = [1, 2, 3]
 b = a
 b = [4, 5]
 print(a)
 print(b)
Â¿Por quÃ© a pesar de haber hecho b = a el cambio posterior en b no afecta a a?
Â¿QuÃ© estÃ¡ pasando en la lÃ­nea b = [4, 5]?
âœï¸ Respuestas:

...
...
...
...
...
ğŸ” De uno por uno... Â¡a todos juntos!
La tienda estÃ¡ interesada en saber cuÃ¡nto vendiÃ³ en promedio por mes durante el Ãºltimo aÃ±o.

Hasta ahora, sabemos cÃ³mo acceder a cada elemento de la lista individualmente:

ventas = [320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330]

print(ventas[0])
print(ventas[1])
print(ventas[2])
# y asÃ­...
Para sumar todas las ventas podrÃ­amos escribir esto:

suma_ventas = ventas[0] + ventas[1] + ventas[2] + ventas[3] + ventas[4] + ventas[5] + ventas[6] + ventas[7] + ventas[8] + ventas[9] + ventas[10] + ventas[11]
Pero... Â¿y si la lista tuviera 100 o 1000 valores? ğŸ˜±

Â¿HabrÃ¡ una forma mÃ¡s prÃ¡ctica de hacer este tipo de cÃ¡lculos en la compu? ğŸ¤”

MirÃ¡ este cÃ³digo, lÃ©e cada lÃ­nea y pensÃ¡ quÃ© hace. DespuÃ©s ejecutalo para ver los resultados:


[ ]
ventas = [320, 280, 310, 290, 340, 360, 410, 390, 370, 350, 300, 330]

i = 0
suma_ventas = 0

while i < len(ventas):
    suma_ventas = suma_ventas + ventas[i]
    i = i + 1

media_ventas = suma_ventas / len(ventas)

print("Media de ventas:", media_ventas)
ğŸ“Œ RespondÃ©:

Â¿Para quÃ© sirve la variable i? Â¿Por quÃ© empieza en 0?
Â¿QuÃ© hace len(ventas)? Â¿Para quÃ© se usa en el cÃ³digo?
Â¿QuÃ© tipo de valor devuelve i < len(ventas)?
Â¿QuÃ© representa el valor guardado en suma_ventas? Â¿CÃ³mo se calcula?
Â¿QuÃ© hace la lÃ­nea i = i + 1? Â¿Por quÃ© es importante?
ğŸŒ€ IteraciÃ³n
Cuando programamos, muchas veces necesitamos repetir una acciÃ³n varias veces. Por ejemplo, si queremos sumar todas las ventas registradas en una lista, debemos recorrer la lista, acceder a cada elemento y sumarlo al total, uno por uno, hasta llegar al final.

Escribir el mismo cÃ³digo para cada elemento es muy trabajoso, ineficiente y propenso a errores. Para resolver este tipo de tareas repetitivas, en programaciÃ³n usamos el concepto de iteraciÃ³n.

La iteraciÃ³n consiste en repetir una serie de instrucciones varias veces, generalmente mientras se cumpla una condiciÃ³n especÃ­fica.

Dentro de las ventajas de la iteraciÃ³n tenemos que:

Permite automatizar tareas repetitivas.
Facilita trabajar con grandes cantidades de datos.
Hace que el cÃ³digo sea mÃ¡s corto, claro y eficiente.
ğŸ” Ciclos o bucles
Los ciclos (tambiÃ©n llamados bucles) son los mecanismos que permiten llevar a cabo estas repeticiones.

Cada vez que se ejecuta el bloque de cÃ³digo dentro de un ciclo, se produce una iteraciÃ³n.

En otras palabras:

Un ciclo es la estructura que se encarga de repitir instrucciones.
Una iteraciÃ³n es cada ejecuciÃ³n individual del bloque de cÃ³digo dentro del ciclo.
ğŸ”„ El ciclo while
Una de las estructuras mÃ¡s comunes para realizar iteraciones es el ciclo while.

En el ejemplo de las ventas usamos este ciclo para sumar todos los elementos de la lista ventas y luego calcular el promedio:

i = 0
suma_ventas = 0

while i < len(ventas):
    suma_ventas = suma_ventas + ventas[i]
    i = i + 1

media_ventas = suma_ventas / len(ventas)
La variable i actÃºa como Ã­ndice para recorrer la lista elemento por elemento. Al iniciar en i = 0, comenzamos por el primer elemento de la lista. Luego, en cada iteraciÃ³n del ciclo, se incrementa en 1 con la instrucciÃ³n i = i + 1, lo que permite avanzar por la lista.

Para ir acumulando la suma total de las ventas usamos la variable suma_ventas que inicializamos en 0. En cada vuelta del ciclo, sumamos el valor actual ventas[i] al total con: suma_ventas = suma_ventas + ventas[i].

Para saber automÃ¡ticamente cuÃ¡ntos elementos tiene la lista, usamos la funciÃ³n integrada en Python llamada len(), que retorna un nÃºmero entero. En este caso, len(ventas) devuelve 12 porque la lista ventas tiene 12 elementos. La cantidad de elementos de una lista se suele denominar longitud de la lista.

La lÃ­nea while i < len(ventas) define la condiciÃ³n del ciclo mediante una expresiÃ³n lÃ³gica. En este caso, queremos que el ciclo se repita mientras i sea menor que la longitud de la lista. Esta condiciÃ³n serÃ¡ True hasta que se procese el Ãºltimo elemento de la lista. Luego, cuando i el valor len(ventas), la condiciÃ³n se vuelve False y el ciclo termina.

ğŸ–¥ï¸ Â¿QuÃ© va dentro del while?

Dentro del cÃ³digo del while definimos las acciones que se repiten en cada iteraciÃ³n. En nuestro caso:

Acceder al elemento actual de la lista con ventas[i] y sumarlo al total suma_ventas.
Incrementar i para avanzar al siguiente elemento.
AsÃ­, la compu recorre toda la lista de principio a fin. Cada vez que ejecutamos el bloque de cÃ³digo dentro del ciclo while, se cumple una iteraciÃ³n del ciclo. En este caso, se realizan en total 12 iteraciones (una por cada mes de ventas).

Al finalizar el ciclo, tenemos la suma de todas las ventas en suma_ventas. Luego, calculamos la media de ventas haciendo media_ventas = suma_ventas / len(ventas).

En el siguiente diagrama de flujo podÃ©s ver como se comporta un ciclo while. El cÃ³digo dentro de ciclo se repite mientras la condiciÃ³n sea verdadera y cada repeticiÃ³n es una iteraciÃ³n del ciclo. Cuando la condiciÃ³n se vuelve falsa, el ciclo termina.


ğŸ” Para analizar el ejemplo de las ventas paso a paso podÃ©s visualizarlo con Python Tutor acÃ¡.

ğŸ§  Preguntas:

Si en lugar de 12 tuviÃ©ramos 100, 1000 o 10.000 ventasâ€¦ Â¿serÃ­a necesario cambiar algo dentro del while?
Â¿QuÃ© sucederÃ­a si la condiciÃ³n del ciclo fuera i <= len(ventas) en lugar de i < len(ventas)?
Â¿QuÃ© pasarÃ­a si dentro del ciclo se incrementara i antes de sumar la venta correspondiente??
Si i empezara en 1 en lugar de 0, Â¿quÃ© parte de la lista quedarÃ­a sin sumar?
Â¿Y si ventas fuera una lista vacia: ventas = []?
Â¿QuÃ© valor devolverÃ­a len(ventas)?
Â¿Se ejecutarÃ­a el ciclo while alguna vez?
Â¿QuÃ© valor final tendrÃ­a suma_ventas?
âœï¸ Respuestas:

...
...
...
...
...
ğŸ§® Â¡Necesitamos un contador!
Ya calculamos la media de ventas mensuales. Ahora queremos saber en cuÃ¡ntos meses las ventas estuvieron por encima de esa media.

El siguiente cÃ³digo intenta hacer esoâ€¦ pero tiene algunos errores ğŸ™ˆ.

Â¿PodÃ©s encontrarlos y corregirlos? ğŸ› ï¸


[ ]
i = 1
conteo_meses = 0

while i < len(venta)
    if ventas[] > media_ventas:
        conteo_meses = conteo_meses - 1
    i = i

print("Meses con ventas por encima de la media:", conteo_meses)
ğŸ“Œ RespondÃ©:

Â¿QuÃ© funciÃ³n cumple la variable conteo_meses? Â¿En quÃ© momento se actualiza su valor?
Â¿QuÃ© hace la condiciÃ³n ventas[i] > media_ventas?
Â¿QuÃ© tipos de errores hay en el cÃ³digo?
â¡ï¸ IndentaciÃ³n en ciclos
Al igual que vimos en la clase 2 con los condicionales, la indentaciÃ³n juega un papel fundamental cuando escribimos estructuras repetitivas como un ciclo while.

Hay dos reglas clave que tenemos que seguir para que el cÃ³digo funcione correctamente:

Agregar dos puntos (:) al final de la lÃ­nea del while.
Indentar (es decir, dejar sangrÃ­a) en las lÃ­neas que estÃ¡n dentro del bloque del ciclo.
Esto le indica a la compu quÃ© instrucciones debe repetir dentro del while.

Por ejemplo, en este cÃ³digo:

while i < len(ventas):
if ventas[i] > media_ventas:
    conteo_meses = conteo_meses + 1
i = i + 1
Faltan los dos puntos al final del while y el bloque dentro del while no estÃ¡ indentado. Lo correcto serÃ­a asÃ­:

while i < len(ventas):
    if ventas[i] > media_ventas:
        conteo_meses = conteo_meses + 1
    i = i + 1
ğŸ“Œ Recordemos que cuando no respetamos las reglas de indentaciÃ³n la compu nos mostrarÃ¡ un mensaje de error. Lo mÃ¡s comÃºn es indentar usando cuatro espacios o presionar la tecla Tab en el teclado.

âœ… Contadores y acumuladores
Cuando usamos ciclos hay dos patrones muy comunes que nos ayudan a resolver muchos problemas: los contadores y los acumuladores.

Un contador es una variable que usamos para contar cuÃ¡ntas veces sucede algo. En el ejemplo, queremos saber cuÃ¡ntos meses tuvieron ventas por encima de la media. Para ello, usamos la variable contador conteo_meses:

if ventas[i] > media_ventas:
    conteo_meses = conteo_meses + 1
El incremento del contador tambiÃ©n se puede escribir usando el operador +=:

if ventas[i] > media_ventas:
    conteo_meses += 1
Cada vez que se cumple esta condiciÃ³n, sumamos 1 al contador.

Un acumulador es una variable que usamos para sumar valores que van cambiando. Por ejemplo, para calcular la media de ventas, primero sumamos todas las ventas usando la variable acumuladora suma_ventas:

suma_ventas = suma_ventas + ventas[i]
El incremento del acumulador tambiÃ©n puede escribirse asÃ­:

suma_ventas += ventas[i]
En cada vuelta del ciclo, el acumulador suma el valor actual de la lista.

ğŸ“Œ Tanto los contadores como los acumuladores deben ser inicializados antes del ciclo, normalmente con el valor 0. Si no los inicializamos, la compu mostrarÃ¡ un error diciendo que la variable no estÃ¡ definida.

ğŸ§  Preguntas:

Â¿CÃ³mo modificarÃ­as el cÃ³digo de arriba para contar los meses con ventas por debajo de la media?

Â¿QuÃ© pasa si el incremento de i se hiciera dentro del bloque if?

ObservÃ¡ este cÃ³digo:

 x = 1
 while x <= 6:
     x = x + 2
Â¿CuÃ¡ntas veces se repite el ciclo?
Â¿CuÃ¡l es la Ãºltima asignaciÃ³n de x dentro del ciclo?
En el siguiente fragmento de cÃ³digo, Â¿cuÃ¡l es el propÃ³sito de cada variable?

 suma = 0
 cantidad = 0
 while i < len(numeros):
     if numeros[i] % 2 == 0:
         suma = suma + numeros[i]
         cantidad = cantidad + 1
     i = i + 1
El siguiente cÃ³digo es un ejemplo de un ciclo infinito. Â¿PodÃ©s explicar por quÃ© se llama asÃ­? Â¿CÃ³mo lo corregirÃ­as?

 i = 0
 while i < 5:
     print("Hola")
âœï¸ Respuestas:

...
...
...
...
...
ğŸ¯ Â¿Llegamos al objetivo?
Supongamos que la tienda quiere saber si en algÃºn mes se alcanzÃ³ un objetivo de ventas, por ejemplo, de 400 mil unidades. Si se cumple, debemos informar en quÃ© mes se logrÃ³ por primera vez.

MirÃ¡ este cÃ³digo, lÃ©e cada lÃ­nea y pensÃ¡ quÃ© hace. DespuÃ©s ejecutalo para ver los resultados:


[ ]
objetivo = 400

i = 0
objetivo_cumplido = False
mes_objetivo = -1

while i < len(ventas) and not objetivo_cumplido:
    if ventas[i] >= objetivo:
        objetivo_cumplido = True
        mes_objetivo = i + 1
    i = i + 1

if objetivo_cumplido:
    print("Objetivo de ventas alcanzado en el mes", mes_objetivo)
else:
    print("No se alcanzÃ³ el objetivo de ventas en ningÃºn mes")
ğŸ“Œ RespondÃ©:

Â¿Para quÃ© sirve la variable objetivo_cumplido? Â¿En quÃ© momento cambia su valor?
Â¿CuÃ¡ndo termina el ciclo? Â¿QuÃ© condiciones lo pueden hacer detenerse?
Â¿QuÃ© hace la lÃ­nea mes_objetivo = i + 1? Â¿Por quÃ© se le suma 1?
Â¿QuÃ© valor tiene mes_objetivo si no se cumple el objetivo? Â¿Por quÃ©?
ğŸš© Cortar el ciclo y variable bandera
Cuando queremos saber si una condiciÃ³n se cumple al menos una vez dentro de una lista, podemos usar una variable bandera.

Una bandera (o flag, en inglÃ©s) es una variable booleana (es decir, con valor True o False) que:

Se inicia en False, porque al principio asumimos que la condiciÃ³n no se cumpliÃ³.
Se vuelve True dentro del ciclo, justo cuando se encuentra un caso que cumple la condiciÃ³n.
Permite cortar el ciclo antes de tiempo, evitando seguir recorriendo la lista innecesariamente.
En el ejemplo usamos la bandera objetivo_cumplido y una condiciÃ³n compuesta en el ciclo:

while i < len(ventas) and not objetivo_cumplido:
Esto permite que el ciclo termine en dos casos:

cuando se acaban los datos (toda la lista fue recorrida), o
cuando se cumple el objetivo de ventas por primera vez.
Si se cumple la condiciÃ³n de ventas, el ciclo puede terminar antes de llegar al final de la lista. Esto hace que el programa sea mÃ¡s eficiente, porque no analiza mÃ¡s datos de los necesarios.

Este patrÃ³n se usa mucho en problemas de bÃºsqueda cuando queremos:

Detectar si una condiciÃ³n se cumple al menos una vez.
Evitar seguir buscando una vez que encontramos lo que necesitÃ¡bamos.
ğŸ“Œ El valor -1 se suele usar como valor por defecto en problemas de bÃºsqueda para representar el caso en el que no se encontrÃ³ lo que estÃ¡bamos buscando. Como -1 no corresponde a ninguna posiciÃ³n vÃ¡lida, es Ãºtil para indicar que no hubo coincidencias.

ğŸ§  Preguntas:

Â¿QuÃ© pasarÃ­a si eliminamos la condiciÃ³n not objetivo_cumplido del ciclo while?

Â¿CÃ³mo modificarÃ­as el cÃ³digo para que tambiÃ©n muestre cuÃ¡ntas unidades se vendieron en el mes en que se alcanzÃ³ el objetivo?

Â¿De quÃ© otra manera podrÃ­as detener el ciclo while sin usar una variable bandera? PensÃ¡, por ejemplo, cÃ³mo podrÃ­as usar el valor de mes_objetivo en reemplazo de objetivo_cumplido en la condiciÃ³n del ciclo.

Si ahora te piden guardar todos los meses que alcanzaron el objetivo. Â¿CÃ³mo lo implementarÃ­as? Â¿NecesitÃ¡s la variable bandera?

ImaginÃ¡ que tenÃ©s una lista de nÃºmeros. CompletÃ¡ el siguiente cÃ³digo para que sume los nÃºmeros uno por uno hasta superar 100, y luego indique cuÃ¡ntos nÃºmeros se necesitaron para llegar a esa suma.

 numeros = [10, 20, 15, 5, 30, 25, 10, 50, 40]
 suma_numeros =
 conteo_numeros =
 i =
 supero_limite =

 while
     suma_numeros =
     conteo_numeros =
     i =

 print("Suma final:", suma_numeros)
 print("Se necesitaron", conteo_numeros, "nÃºmeros para superar 100.")
UsÃ¡ una variable bandera para frenar el ciclo cuando se cumpla la condiciÃ³n.

âœï¸ Respuestas:

...
...
...
...
...
ğŸ“š Recursos adicionales
ğŸ“– En el capÃ­tulo 7 de este libro encontrarÃ¡s mÃ¡s informaciÃ³n sobre iteraciÃ³n y en el capÃ­tulo 10 sobre listas.
ğŸ”— ExplorÃ¡ mÃ¡s de Python Tutor para crear y visualizar tus propios programas.
Productos pagados de Colab - Cancela los contratos aquÃ­

